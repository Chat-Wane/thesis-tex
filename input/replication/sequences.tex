
\section{Séquences répliquées}
\label{repl:sec:sequences}

Une séquence, ou liste, ou tableau, est une série d'éléments ordonnés les uns à
la suite des autres. Une séquence répliquée doit donc ordonner de la même
manière ses éléments indépendamment du serveur l'hébergeant. Les approches à
base de transformés opérationnels adaptent les arguments des opérations afin de
recouvrer un contexte d'exécution valide (cf. §\ref{repl:subsec:ot}). Les CRDTs
pour séquences, eux, choisissent de surcharger les éléments de métadonnées de
telle sorte que les métadonnées permettent de recouvrer un ordre identique
partout. Une différence fondamentale entre les deux types d'approches concerne
la signature des opérations. Lorsque OT conserve une signature d'opération
classique (``insérer l'élément $e$ à l'indice $i$''), les CRDTs positionnent
leurs éléments relativement aux éléments adjacents à l'indice ciblé (``insérer
l'élément $e$ entre l'élément $a$ et l'élément $b$''). Avec ce procédé, des
métadonnées -- nommées identifiants -- seront générées garantissant, grâce à un
ordre total sur ces identifiants, que le nouvel élément serat bel et bien placé
entre ces deux bornes.

\subsection{Pierres tombales}

Les structures de données sans résolution de conflits
(cf. chapitre~\ref{repl:chap:crdts}) pour séquences évitent le coûteux processus
de detection de concurrence. Les approches de cette famille utilisant des
pierres tombales~\cite{ahmed2011evaluating, conway2014language,
  grishchenko2010deep, oster2006data, preguica2009commutative,
  roh2011replicated, weiss2007wooki, wu2010partial, yu2012stringwise} se
caractérisent par la manière dont les suppressions sont traitées. En effet, lors
de l'opération de suppression, ces approches marquent simplement les éléments
supprimés afin de les cacher à l'utilisateur. Bien que supprimées, ces pierres
tombales existent toujours dans la structure représentant la séquence et
continuent d'impacter sur les performances.

\begin{itemize}
\item [\textbf{WOOT~\cite{oster2006data} :}] le premier représentant historique
  des CRDTs pour séquences suivit par deux extensions
  \textbf{WOOTO~\cite{weiss2007wooki}} et
  \textbf{WOOTH~\cite{ahmed2011evaluating}}. Dans cette approche chaque
  identifiant référence les identifiants voisins à l'insertion. Rassemblés, les
  identifiants peuvent être ordonnés grâce à un diagramme de Hasse
  (\REF). Toutefois, cet ordonnancement requière des deux bornes adjacentes
  qu'elles soient déjà intégrées et toujours présentes, d'où les suppressions
  réelles impossibles.

  \begin{figure}
    \centering
    \input{input/replication/wootexample.tex}
    \caption{\label{repl:fig:wootexample}Le diagramme de Hasse du modèle WOOT
      représentant la séquence 'QWERTY'. Bien que supprimé, le caractère Z est
      indispensable au bon ordonnancement de la séquence.}
  \end{figure}

  La figure~\ref{repl:fig:wootexample} illustre la nécessité de conserver les
  pierres tombales. Elle montre le diagramme de Hasse généré lors du scenario
  suivant : Tout d'abord, un utilisateur écrit 'AZERTY'. Ensuite, les deux
  premiers caractères sont supprimés afin d'être remplacés par les caractères
  'QW'. La séquence finale est 'QWERTY'. Toutefois, les identifiants ne sont pas
  modifiables, et l'identifiant du caractère 'E' référence l'identifiant de 'Z',
  lui-même référençant l'identifiant de 'A'. Par conséquent, supprimer
  complètement les identifiants de 'A' et/ou de 'Z' revient à rendre
  l'identifiant de 'E' non positionnable, et tout ceux qui en dépendent par
  transitivité.

\item [\textbf{Causal tree~\cite{grishchenko2010deep} :}] caractérise
  explicitement les relations causales grâce à une réprésentation sous forme
  d'arbre. Ainsi, chaque opération est accompagnée de l'identifiant de la
  dernière opération observée. En parcourant l'arbre et en appliquant les
  opérations, la séquence peut être retrouvée. Toutefois, les identifiants sont
  des horloges vectorielles (\emph{vector clock}) dont la taille est prohibitive
  (\REF). De plus, il est nécessaire de conserver tous les noeuds de cet arbre
  causal au cas où une opération y ferait référence.
\item [\textbf{Partial persistent sequence~\cite{wu2010partial} :}] definit les
  identifiants dans l'ensemble des nombres rationnels auxquel est ajoutée une
  limite quant à leur précision. Hélas, cette limite contraint la taille du
  document maximale. \TODO{Moar?}. \TODO{Maybe falls in the other category.}
\item [\textbf{Replicated growable array~\cite{roh2011replicated} :}] représente
  la séquence sous forme de liste supportant les opérations concurrentes. Une
  table de hachage apporte un accès rapide aux éléments grâce à leurs
  identifiants. Les éléments incluent une référence au voisin qu'ils précèdent
  lors de leur insertion. Toutefois, pour ne jamais briser la chaine ainsi
  construite, les éléments supprimés restes présents indéfinitivement mais
  cachés de l'utilisateur. \TODO{Double check.}
\item [\textbf{String-wise~\cite{yu2012stringwise} :}] cible principalement les
  chaines de caractères pouvant être subdivisées lors d'opérations. Les
  identifiants référencent alors les chaines adjacentes à l'insertion ainsi que
  les autres éléments de la chaines si subdivision il y a. De la même manière
  que pour les approches précédentes, les références rendent les suppressions
  réelles impossibles.
\item [\textbf{DiCE~\cite{conway2014language} :}] concentre principalement ses
  efforts sur les garanties de \TODO{\emph{confluence}} de la séquence. Chaque
  identifiant référence le voisin qu'il précède à l'insertion. L'ordre des
  éléments est alors fonction de ces relations de positionnement relatif, et de
  causalité.
\end{itemize}

Bien que l'accent soit mit sur l'impossibilité de réellement supprimer les
éléments de séquences répliquées, toutes ces approches s'avèrent pratiques
lorsque l'historique des opérations doit être conservé. Par exemple, dans le
cadre de l'encyclopédie \emph{Wikipédia}, conserver toutes les modifications
éffectuées permet de recouvrer une version vierge de vandalisme; dans le cadre
du gestionnaire de versions \emph{Git}, il permet de recouvrer une version du
code potentiellement sans erreurs etc. Malheureusement, ces structures
grandissent au moins linéairement comparativement au nombre d'opérations
effectuées sur la séquence. Cela devient paradoxalement problématique, par
exemple, lors de vandalisme où même le contenu indésirable est conservé
indéfinitivement. Survient alors le frustrant constat d'avoir à stocker un
fichier dont le poid ne reflète pas le contenu visible. De plus, les éléments
cachés s'accumulent et dégradent \TODO{continuellement} les performances du
système.

Lorsque conserver l'historique ne constitue pas une contrainte, purger la
structure de données des éléments cachés constitue une solution potentielle aux
dégradations de performances :

\begin{itemize}
\item [\textbf{ramasse-miètes~\cite{abdullahi1998garbage} :}] permet de nettoyer
  une structure de données en vidant de la mémoire les objets qui ne sont plus
  accessibles par le programme. Le contexte \textbf{réparti} étend le cadre du
  programme en considérant le local et le distant. Ainsi, supprimer réellement
  un élément de la séquence revient à s'interroger : \emph{Est-ce que
    \begin{inparaenum}[(i)]
    \item toutes les répliques ont supprimé l'élément et
    \item est-ce que tous les éléments référençant l'élément supprimé ont été
      intégré localement?
    \end{inparaenum}} Cela va sans dire qu'il est difficile d'apporter une
  réponse à ces deux questions. D'autant plus lorsque les possesseurs de
  réplique ne sont pas perpétuellement joignables.
\item [\textbf{core-nebula~\cite{letia2009crdts} :}] propose de contraindre la
  topologie réseau afin de rendre les \TODO{consensus} possibles. Ainsi, un
  coeur décisionnel prend en charge les choix de suppression réelle des objets.
  Ce coeur décisionnel étant restraint à un sous-ensemble des membres du réseaux
  étant toujours accessibles, les décisions peuvent alors être prises de manière
  fiable. Le reste des participants se conforme alors aux décisions prises par
  le coeur \TODO{au risque de perdre certaines de leurs modifications}.
\end{itemize}

La section suivante présente une famille de structures pour séquences dont le
bon fonctionnemement ne requière pas de pierres tombales (\TODO{Treedoc\ldots}).

\subsection{Identifiants de taille variable}

Certaines structures de données sans résolution de conflits pour séquences
utilisent des identifiants dont la taille est variable à la
génération~\cite{andre2013supporting, preguica2009commutative,
  weiss2009logoot}. Ainsi, les identifiants sont toujours uniques et immuables
une fois générés, mais leur structure contient une liste d'éléments encodant
leur position dans la séquence.  Contrairement aux approches basées sur les
pierres tombales, ces identifiants ne dépendent pas d'autres identifiants afin
d'être intégrés. À ce titre, les suppressions peuvent ne se contentent pas de
masquer les éléments, mais les retirent entièrement de la structure. En
revanche, la liste d'éléments constituants les identifiants est susceptible de
grandir \TODO{impactant les performances}. 

Nous définissons le modèle suivant : le CRDT pour séquences est un arbre
$\mathcal{T}$ initialisé vide (\TODO{Bornes}) équippé des opérations d'insertion
$insert$ et de suppression $delete$. Un identifiant dans $\mathcal{I}$ contient
un chemin dans $\mathcal{P}$, un désambiguateur dans $\mathcal{D}$, et un
élément dans $\mathcal{A}$. L'union des identifiants non supprimés crée l'arbre
$\mathcal{T}$ où chaque noeud possède au plus un élément.  En utilisant un ordre
total $(\mathcal{I},\, <_\mathcal{I})$, l'arbre est transformé en séquence
d'éléments. \TODO{double-check.}

\begin{wrapfigure}{r}{0.5\textwidth}
  \vspace{-35pt} %% (ugly)
  \begin{minipage}[t]{0.5\textwidth}
    \begin{algorithm}[H]
      \input{input/replication/crdtabstractalgo.tex}
      \caption{\label{repl:algo:crdtabstract} Squelette.}
    \end{algorithm}
  \end{minipage}
  \vspace{-35pt}
\end{wrapfigure}

L'algorithme~\ref{repl:algo:crdtabstract} présente le squelette de cette famille
de structure pour séquence.  Il est divisé en deux parties qui correspondent à
l'exécution locale et l'exécution distante de la réplication
optimiste. Celles-ci sont elles-mêmes divisées en deux types d'évènements
correspondant aux opérations d'insertions et de suppression d'un
élément. L'algorithme met en lumière trois points :

\begin{itemize}
\item [\textbf{signature :}] les opérations sur la séquence répliquée prennent
  pour arguments les identifiants adjacents à l'insertion, au lieu d'un indice
  dans la séquence pour les séquences \TODO{classiques}.
\end{itemize}

\begin{itemize}
\item [\textbf{complexité locale :}] la complexité de l'algorithme est répartie
  entre la génération d'un identifiant locale et son intégration à la structure
  en partie distante. Cela constitue une différence fondamentale comparée aux
  approches à transformés opérationnels (cf. §~\ref{repl:sec:ot}).
\item [\textbf{allocation de chemin} :] la taille des identifiants dépend
  essentiellement de l'allocation d'un chemin dans l'arbre
  (cf. ligne~\ref{line:allocpath}) auquel est ajouté un désambiguateur
  (cf. ligne~\ref{line:allocdes}) afin de garantir l'unicité de l'identifiant.
\end{itemize}

% \begin{figure*}
%   \centering
%   \subfloat[Allocation quasi-optimale]
%   [\label{fig:lseq:allocpathexampleA}Cas d'une allocation quasi-optimale]
%   {\input{./input/replication/allocpathexampleA.tex}}
%   \hspace{40pt}
%   \subfloat[Pire cas d'allocation]
%   [Pire cas d'allocation]
%   {\input{./input/replication/allocpathexampleB.tex}}
%   \caption{\label{fig:lseq:allocpathexample} Deux arbres remplis d'identifiants
%     résultant de deux séquences d'édition différentes et dont la séquence finale
%     est identique : $QWERTY$. L'allocation des identifiants se fait selon le
%     même algorithme qui alloue la branche la plus à gauche de l'arbre. L'arbre
%     quasiment optimal ne possède que des branches de profondeur 1 tandis que
%     l'arbre pire cas atteint une profondeur de 6.}
% \end{figure*}

Les figures~\ref{repl:fig:allocpathexampleA} et~\ref{repl:fig:allocpathexampleB}
illustrent les difficultés rencontrées lors de l'allocation des chemins
composant les identifiants. Dans les deux cas, la fonction d'allocation utilise
la stratégie suivante : la branche la plus à gauche avec la plus petite
profondeur possible. Dans les deux cas, la séquence finale est
'QWERTY'. Toutefois, les lettres ne sont pas insérées dans un ordre
identique. Dans le premier cas, 'Q' est inséré à l'index 0, suivit de 'W' à
l'index 1, suivit de 'E' à l'index 2 etc. Cette séquence d'opérations est nommée
\TODO{\emph{séquence d'édition}} :
\begin{alltt}
\centering(Q,0).(W,1).(E,2).(R,3).(T,4).(Y,5)
\end{alltt}
%%Celle-ci est traduite à la volée par :
%%\begin{alltt}
%%\centering insert(\(\vdash\), Q, \(\dashv\)).insert(\(i_Q\), W, \(\dashv\)).insert(\(i_W\), E, \(\dashv\))...insert(\(i_T\), Y, \(\dashv\))
%%\end{alltt}
Dans le second cas, la lettre 'Y' est insérée à l'index 0, suivit du 'T' à
l'index 0 qui, par effet de bord, décale le 'Y' à l'indice 1. La séquence en
résultant est donc 'TY'. L'insertion du 'R' en position 0 décale toutes lettres
de droite etc. La séquence d'édition qui correspond à ce cas est :
\begin{alltt}
\centering(Y,0).(T,0).(R,0).(E,0).(W,0).(Q,0)
\end{alltt}
%%Traduit par :
%%\begin{alltt}
%%\centering insert(\(\vdash\), Y, \(\dashv\)).insert(Q, W, \(\dashv\)).insert(W, E, \(\dashv\))...insert(T, Y, \(\dashv\))
%%\end{alltt}

\begin{wrapfigure}{r}{0.5\textwidth}
  \vspace{-15pt}
  \centering
  \input{input/replication/allocpathexampleA.tex}
  \caption{\label{repl:fig:allocpathexampleA}Allocation quasi-optimale}
  \vspace{-15pt}
\end{wrapfigure}

\textbf{Premier cas :} L'opération d'insertion (Q, 0) est transformée en
insert($\vdash$, Q, $\dashv$). Par conséquent, le chemin doit être alloué entre
les bornes virtuelles [0] et [9]. Puisque la stratégie d'allocation consiste à
reserver la branche la plus à gauche et de plus petite taille, le chemin
résultant est [1]. Ensuite, l'opération (W, 1) est transformée en insert($i_Q$,
W, $\dashv$) résultant sur le chemin [2] etc.  Dans ce cas, la profondeur de
l'arbre n'augmente jamais. À cet égard, la stratégie employée par la fonction
$allocPath$ est très efficace. Cependant, elle n'est pas totalement optimale
puisque l'arbre est prévu pour accueillir 8 identifiants lorsque seulement 6
sont alloués.

\begin{wrapfigure}{r}{0.5\textwidth}
  \vspace{-10pt}
  \centering
  \input{input/replication/allocpathexampleB.tex}
  \caption{\label{repl:fig:allocpathexampleB}Allocation pire-cas}
  \vspace{-10pt}
\end{wrapfigure}

\textbf{Second cas :} De la même manière, l'opération d'insertion (Y, 0) est
transformée en insert($\vdash$, Y, $\dashv$) dont le résultat est le chemin
[1]. Lors de l'insertion (T, 0), un chemin est requis entre la borne virtuelle
du début de séquence [0] et la borne du caractère 'Y' [1]. Ainsi, la profondeur
du chemin doit grandir de telle sorte que le nouvel identifiant muni de l'ordre
total $(\mathcal{I},\,<_\mathcal{I})$ soit placé entre les deux. Considérons un
ordre lexicographique, le chemin résultant est [0.X] où X est choisit entre 0 et
10. Suivant la stratégie, le chemin est [0.1] pour la lettre 'T'. Puis [0.0.1]
pour la lettre 'R' etc. La taille des chemins alloués augmente très rapidement.
La stratégie de la fonction $allocPath$ s'avère inéfficace dans ce cas.

Cet exemple montre à quel point l'ordre d'insertion des éléments affecte la
longueur des chemins alloués. Malheureusement, ni la séquence d'édition, ni sa
taille ne sont connues par avance.  Passer d'indices locaux mutables et optimaux
(\TODO{séquence classique}) à des identifiants non-mutable de taille variable a
donc un coût qu'il est nécéssaire d'analyser afin de proposer une fonction
d'allocation efficace.

%% C'est pourquoi les travaux précédents font souvent l'hypothèse d'un
%% comportement d'édition de gauche-à-droite basés sur observations. Toutefois,
%% il existe des documents écrit par l'homme dont le comportement ne correspond
%% pas à celui-ci.

\begin{itemize}
\item [\textbf{Logoot~\cite{weiss2009logoot, weiss2010logootundo} :}] représente
  un identifiant sous forme de liste où chaque élément du chemin possède un
  désambiguateur associé. Ce dernier est composé d'un identifiant unique de
  réplique ainsi qu'un compteur incrémenté à chaque opération. Un identifiant
  est donc :
  \begin{equation*}
    \langle
    \alpha ,\,
    \DARKBLUE{[p_1.p_2\ldots p_k]},\,
    [\langle s_1,\,c_1 \rangle. \langle s_2,\,c_2\rangle \ldots \langle s_k, c_k\rangle ]
    \rangle
  \end{equation*}
  où $\alpha$ est la lettre insérée, $k$ la profondeur de l'identifiant,
  $p_{1\ldots k}$ le chemin dans l'arbre,
  $\langle s_{1\ldots k},\, c_{1\ldots k}\rangle$ les désambiguateurs
  associés. Soit une position $\ell_i$ constituée du triplet
  $\langle p_i,\,s_i,\,c_i\rangle$, et un ordre total parmis ceux-ci:
  \begin{align*}
    \ell_i < \ell_j \iff & (p_i < p_j) \vee \\
                         & ((p_i = p_j) \wedge (s_i<s_j)) \vee \\
                         & ((p_i = p_j) \wedge (s_i = s_j) \wedge (c_i < c_j)) \\
    \ell_i = \ell_j \iff & \neg (\ell_i < \ell_j) \wedge \neg (\ell_j < \ell_i)
  \end{align*}
  L'ordre total utilisé pour recouvrer la séquence est l'ordre lexicographique
  tel que $i_1 < i_2$ si et seulement si :
  \begin{align*}
    i_i < i_j \iff & \exists (m > 0)(\forall n < m) (\ell^i_n = \ell^j_n) \wedge (\ell^i_m \
                     < \ell^j_m) \\
    i_i = i_j \iff & (\forall n) \ell^i_n = \ell^j_n
  \end{align*}
  En d'autres termes, l'identifiant $i_1$ précède $i_2$ si et seulement si le
  premier élément de $i_1$ qui les distingues est inférieur. Par ailleurs, par
  défaut $\ell_d = \langle 0,\,\_,\,0 \rangle$
  lorsque $d > k$. Les identifiants étant uniques, il existe toujours un tel
  $m$.

  \TODO{Le modèle présenté plus tôt se base sur un arbre. Toutefois,
    l'implémentation proposée originellement par Logoot est celle d'une
    liste}. Ainsi les séquences des figures~\ref{repl:fig:allocpathexampleA}
  et~\ref{repl:fig:allocpathexampleB} sont représentés de la façon suivante :

  \begin{minipage}{0.3\textwidth}
    \begin{alltt}
\(\langle\)\textbf{Q}, [1], [\(\langle a, 1 \rangle\)]\(\rangle\)
\(\langle\)\textbf{W}, [2], [\(\langle a, 2 \rangle\)]\(\rangle\)
\(\langle\)\textbf{E}, [3], [\(\langle a, 3 \rangle\)]\(\rangle\)
\(\langle\)\textbf{R}, [4], [\(\langle a, 4 \rangle\)]\(\rangle\)
\(\langle\)\textbf{T}, [5], [\(\langle a, 5 \rangle\)]\(\rangle\)
\(\langle\)\textbf{Y}, [6], [\(\langle a, 6 \rangle\)]\(\rangle\)
    \end{alltt}
  \end{minipage}
  \hfill
  \begin{minipage}{0.55\textwidth}
    \begin{alltt}
\(\langle\)\textbf{Q}, [0.0.0.0.0.1], [\(\langle \_, 0 \rangle^5\).\(\langle a, 6 \rangle\)]\(\rangle\)
\(\langle\)\textbf{W}, [0.0.0.0.1], [\(\langle \_, 0 \rangle^4\).\(\langle a, 5 \rangle\)]\(\rangle\)
\(\langle\)\textbf{E}, [0.0.0.1], [\(\langle \_, 0 \rangle^3\).\(\langle a, 4 \rangle\)]\(\rangle\)
\(\langle\)\textbf{R}, [0.0.1], [\(\langle \_, 0 \rangle^2\).\(\langle a, 3 \rangle\)]\(\rangle\)
\(\langle\)\textbf{T}, [0.1], [\(\langle \_, 0 \rangle\).\(\langle a, 2 \rangle\)]\(\rangle\)
\(\langle\)\textbf{Y}, [1], [\(\langle a, 1 \rangle\)]\(\rangle\)
    \end{alltt}
  \end{minipage}\\
  Où $a$ est l'identifiant de réplique où les insertions ont été effectuées et
  $\langle \_,\, 0 \rangle^k$ est une façon compressée de représenter $k$ fois
  le désambiguateur de la borne virtuelle inferieure. Cette implémentation de la
  séquence présente comme avantage la rapidité d'accès au prix d'une forte
  occupation mémoire. Plus précisément, lors de la transformation de séquence
  d'édition, il est nécéssaire de retrouver les identifiants adjacents à la
  position d'insertion :
  \begin{alltt}
\centering(W, \BLUE{1}) \(\rightarrow\) insert(\DARKBLUE{\(\langle\)\textbf{Q}, [1], [\(\langle a, 1 \rangle\)]\(\rangle\)}, W, \DARKBLUE{\(\dashv\)})
  \end{alltt}
  \TODO{Base de $2^{64}$}.
  Dans Logoot, cette transformation est effectuée en temps \textbf{constant}
  $\mathcal{O}(1)$. En revanche, chaque identifiant possède une compléxité
  spatiale \textbf{linéaire} $\mathcal{O}(I)$ avec $I$ le nombre d'insertions
  effectuées sur la séquence. N'étant factorisé en aucune manière, la séquence
  possède une complexité spatiale \textbf{quadratique} $\mathcal{O}(I^2)$.

\item [\textbf{Logoot split~\cite{mehdi2014merging} :}] étend Logoot lui offrant
  la possibilité d'adapter la granularité de l'élément ciblé. Bien que tous les
  exemples précédent fassent mention de caractères comme éléments de la
  séquence, Logoot peut fixer la granularité à la ligne, ou au paragraphe, ou à
  la section etc. Cette extension prend pour granularité la chaine de caractère
  avec la liberté de la séparer si besoin est. \TODO{Comme string-wise.}

\item [\textbf{Treedoc~\cite{shapiro2011comprehensive} :}] représente le
  document sous forme d'arbre binaire avec parcours infixe.  Ainsi, si l'on
  considère un élément 'W' dont le chemin est [0], alors un élément 'Q' dont le
  chemin est [0.0] précède 'W', et un élément 'E' dont le chemin est [0.1]
  succède 'W'. En d'autres termes, suffixer le chemin d'un 0 signifie \emph{à
    gauche de}, et suffixer le chemin d'un 1 signifie \emph{à droite de}.
\end{itemize}

