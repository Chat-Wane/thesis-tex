
\section{Séquences répliquées}
\label{repl:sec:sequences}

Une séquence, ou liste, ou tableau, est une série d'éléments ordonnés les uns à
la suite des autres. Une séquence répliquée doit donc ordonner de la même
manière ses éléments indépendamment du serveur l'hébergeant. Les approches à
base de transformés opérationnels adaptent les arguments des opérations afin de
recouvrer un contexte d'exécution valide (cf. §\ref{repl:subsec:ot}). Les CRDTs
pour séquences, eux, choisissent de surcharger les éléments de métadonnées de
telle sorte que les métadonnées permettent de recouvrer un ordre identique
partout. Une différence fondamentale entre les deux types d'approches concerne
la signature des opérations. Lorsque OT conserve une signature d'opération
classique (``insérer l'élément $e$ à l'indice $i$''), les CRDTs positionnent
leurs éléments relativement aux éléments adjacents à l'indice ciblé (``insérer
l'élément $e$ entre l'élément $a$ et l'élément $b$''). Avec ce procédé, des
métadonnées uniques et non-mutables -- nommées identifiants -- seront générées
garantissant, grâce à un ordre total sur ceux-ci, que le nouvel élément serat
bel et bien placé entre ces deux bornes. La suppression est également différente
puisque sa signature devient l'élément ciblé et non un indice (``supprimer
l'élément $e$'').

Nous identifions deux familles d'approches générant des identifiants. La
première génère des identifiants de petite taille mais utilise des pierres
tombales pour indiquer la suppression d'un élément
(cf. §\ref{repl:subsec:tombstone}). La seconde se passe de pierres tombales mais
ses identifiants sont de taille variable lors de la génération
(cf. §\ref{repl:subsec:variable}).

\subsection{Pierres tombales}
\label{repl:subsec:tombstone}

Une pierre tombale est une marque laissée après la suppression d'un élément
indiquant qu'un jour, celui-ci a existé, et qu'il était positionné là. Bien
entendu, ces marques sont cachées à l'utilisateur et n'apparaissent que dans la
structure sous-jacente. L'impact sur les performances en reste néanmoins
présent.

\begin{itemize}
\item [\textbf{WOOT~\cite{oster2006data} :}] est le premier représentant
  historique des CRDTs pour séquences suivit par deux extensions
  \textbf{WOOTO~\cite{weiss2007wooki}} et
  \textbf{WOOTH~\cite{ahmed2011evaluating}}. Dans cette approche chaque
  identifiant référence les identifiants voisins à l'insertion.  Lorsqu'ils sont
  rassemblés, les identifiants peuvent être ordonnés grâce à un diagramme de
  Hasse (\REF). Toutefois, cet ordonnancement requière des deux bornes
  adjacentes qu'elles soient
  \begin{inparaenum}[(i)]
  \item déjà intégrées et
  \item toujours présentes.
  \end{inparaenum}
  D'où les suppressions réelles impossibles.

  \begin{figure}
    \centering
    \input{input/replication/wootexample.tex}
    \caption{\label{repl:fig:wootexample}Le diagramme de Hasse du modèle WOOT
      représentant la séquence 'QWERTY'. Bien que supprimé, le caractère Z est
      indispensable au bon ordonnancement de la séquence.}
  \end{figure}

  La figure~\ref{repl:fig:wootexample} illustre la nécessité de conserver les
  pierres tombales. Elle montre le diagramme de Hasse généré lors du scenario
  suivant : Tout d'abord, un utilisateur écrit 'AZERTY'. Ensuite, les deux
  premiers caractères sont supprimés afin d'être remplacés par les caractères
  'QW'. La séquence finale est 'QWERTY'. Toutefois, les identifiants ne sont pas
  modifiables, et l'identifiant du caractère 'E' référence l'identifiant de 'Z',
  lui-même référençant l'identifiant de 'A'. Par conséquent, supprimer
  complètement les identifiants de 'A' et/ou de 'Z' revient à rendre
  l'identifiant de 'E' non positionnable, et tout ceux qui en dépendent par
  transitivité.

\item [\textbf{Causal tree~\cite{grishchenko2010deep} :}] caractérise
  explicitement les relations causales grâce à une réprésentation sous forme
  d'arbre. Ainsi, chaque opération est accompagnée de l'identifiant de la
  dernière opération observée. En parcourant l'arbre et en appliquant les
  opérations, la séquence peut être retrouvée. Toutefois, les identifiants sont
  des horloges vectorielles (\emph{vector clock}) dont la taille est prohibitive
  (\REF). De plus, il est nécessaire de conserver tous les noeuds de cet arbre
  causal au cas où une opération y ferait référence.
\item [\textbf{Partial persistent sequence~\cite{wu2010partial} :}] definit les
  identifiants dans l'ensemble des nombres rationnels auxquel est ajoutée une
  limite quant à leur précision. Hélas, cette limite contraint la taille du
  document maximale. Sans cette troncature, l'approche serait susceptible
  d'appartenir à l'autre famille de CRDTs pour séquence.
\item [\textbf{Replicated growable array~\cite{roh2011replicated} :}] représente
  la séquence sous forme de liste supportant les opérations concurrentes. Une
  table de hachage apporte un accès rapide aux éléments grâce à leurs
  identifiants. Les éléments incluent une référence au voisin qu'ils précèdent
  lors de leur insertion. Toutefois, pour ne jamais briser la chaine ainsi
  construite, les éléments supprimés restes présents indéfinitivement mais
  cachés de l'utilisateur.
\item [\textbf{String-wise~\cite{yu2012stringwise} :}] cible principalement les
  chaines de caractères pouvant être subdivisées lors d'opérations jusqu'à
  devenir une série de caractères. Les identifiants référencent alors les
  chaines adjacentes à l'insertion ainsi que les autres éléments de la chaines
  si subdivision il y a. De la même manière que pour les approches précédentes,
  les références rendent les suppressions réelles impossibles.
\item [\textbf{DiCE~\cite{conway2014language} :}] concentre principalement ses
  efforts sur les garanties de confluence de la séquence. Chaque identifiant
  référence le voisin qu'il précède à l'insertion. L'ordre des éléments est
  alors fonction de ces relations de positionnement relatif, et de causalité.
\end{itemize}

Bien que l'accent soit mit sur l'impossibilité de réellement supprimer les
éléments de séquences répliquées, toutes ces approches s'avèrent pratiques
lorsque l'historique des opérations doit être conservé. Par exemple, dans le
cadre de l'encyclopédie \emph{Wikipédia} (\REF), conserver toutes les
modifications effectuées permet de recouvrer une version vierge de vandalisme;
dans le cadre du gestionnaire de versions \emph{Git} (\REF), il permet de
recouvrer une version du code potentiellement sans erreurs etc. Malheureusement,
ces structures grandissent au moins linéairement comparativement au nombre
d'opérations faites sur la séquence. Paradoxalement, cela devient problématique
lors de vandalisme où même le contenu indésirable est conservé
indéfinitivement. Survient alors le frustrant constat d'avoir à stocker un
fichier dont le poid ne reflète pas le contenu visible. De plus, les éléments
cachés s'accumulent et dégradent éternellement les performances du système.

Lorsque conserver l'historique ne constitue pas une contrainte, purger la
structure de données des éléments cachés est une solution potentielle aux
dégradations de performances :

\begin{itemize}
\item [\textbf{ramasse-miètes~\cite{abdullahi1998garbage} :}] permet de nettoyer
  une structure de données en vidant de la mémoire les objets qui ne sont plus
  accessibles par le programme. Le contexte réparti étend le cadre du programme
  en considérant le local et le distant. Ainsi, supprimer réellement un élément
  de la séquence revient à s'interroger : \emph{Est-ce que
    \begin{inparaenum}[(i)]
    \item toutes les répliques ont supprimé l'élément et
    \item est-ce que tous les éléments référençant l'élément supprimé ont été
      intégré localement?
    \end{inparaenum}} Cela va sans dire qu'il est difficile d'apporter une
  réponse à ces deux questions. D'autant plus lorsque les possesseurs de
  réplique ne sont pas perpétuellement joignables. Des problématiques
  appartenant jusqu'alors à la réplication pessimiste apparaissent
  (cf. §\ref{repl:subsec:pessimistic}).
% \item [\textbf{core-nebula~\cite{letia2009crdts} :}] propose de contraindre la
%   topologie réseau afin de rendre les \TODO{consensus} possibles. Ainsi, un
%   coeur décisionnel prend en charge les choix de suppression réelle des objets.
%   Ce coeur décisionnel étant restraint à un sous-ensemble des membres du réseaux
%   étant toujours accessibles, les décisions peuvent alors être prises de manière
%   fiable. Le reste des participants se conforme alors aux décisions prises par
%   le coeur \TODO{au risque de perdre certaines de leurs modifications}.
\end{itemize}

Comme alternative, il existe une famille de CRDTs conçue pour le type séquence
et dont le bon fonctionnement ne nécessite pas de référencer directement
d'autres identifiants. En cela, ils évitent l'usage des pierres tombales mais
font face à des problèmes concernant la complexité spatiale de leurs
identifiants.

\subsection{Identifiants de taille variable}
\label{repl:subsec:variable}

Certaines structures de données sans résolution de conflits pour séquences
utilisent des identifiants dont la taille est variable à la
génération~\cite{andre2013supporting, preguica2009commutative,
  weiss2009logoot}. Ainsi, les identifiants sont toujours uniques et immuables
une fois générés, mais leur structure contient une liste d'éléments encodant
leur position relative dans la séquence.  Contrairement aux approches basées sur
les pierres tombales, ces identifiants ne dépendent pas d'autres identifiants
afin d'être intégrés. À ce titre, les suppressions ne se contentent pas de
masquer les éléments, mais les retirent entièrement de la structure. En
revanche, la liste d'éléments constituant les identifiants est susceptible de
grandir, et par là même, de diminuer les performances du systèmes.

Nous définissons le modèle suivant : le CRDT est un arbre $T$ initialisé vide
équippé des opérations d'insertion $\textsc{insert}$ et de suppression
$\textsc{delete}$. Un identifiant dans $\mathcal{I}$ contient un chemin dans
$\mathcal{P}$, un désambiguateur dans $\mathcal{D}$, et un élément dans
l'alphabet $\mathcal{A}$. L'union des identifiants non supprimés crée l'arbre
$T$ où chaque noeud possède au plus un élément.  En utilisant un ordre total
$(\mathcal{I},\, <_\mathcal{I})$, l'arbre est transformé en séquence d'éléments.

Un chemin est une liste d'entiers dont la taille borne celle du désambiguateur :
une liste constituée de paires avec l'identifiant unique du serveur hébergeant
la réplique, et un compteur local à cette réplique (cf. l'exemple des CRDTs pour
compteurs §\ref{repl:subsec:crdts}). La complexité de l'identifiant dépend donc
essentiellement de l'allocation du chemin dans l'arbre.

Les figures~\ref{repl:fig:allocpathexampleA} et~\ref{repl:fig:allocpathexampleB}
illustrent les difficultés rencontrées lors de l'allocation des chemins
composant les identifiants. Dans les deux cas, la fonction d'allocation utilise
la stratégie suivante : la branche la plus à gauche avec la plus petite
profondeur possible. Dans les deux cas, la séquence finale est
'QWERTY'. Toutefois, les lettres ne sont pas insérées dans un ordre
identique. Dans le premier cas, 'Q' est inséré à l'indice 0, suivit de 'W' à
l'indice 1, suivit de 'E' à l'indice 2 etc.  Dans le second cas, la lettre 'Y'
est insérée à l'indice 0, suivit du 'T' à l'indice 0 qui, par effet de bord,
décale le 'Y' à l'indice 1. La séquence en résultant est donc 'TY'. L'insertion
du 'R' en position 0 décale toutes lettres de droite etc.

\begin{wrapfigure}{r}{0.5\textwidth}
  \vspace{-15pt}
  \centering
  \input{input/replication/allocpathexampleA.tex}
  \caption{\label{repl:fig:allocpathexampleA}Allocation quasi-optimale}
  \vspace{-15pt}
\end{wrapfigure}

\textbf{Premier cas :} L'opération d'insertion (Q, 0) est transformée en
\textsc{insert}($\vdash$, Q, $\dashv$). Par conséquent, le chemin doit être
alloué entre les bornes virtuelles [0] et [9]. Puisque la stratégie d'allocation
consiste à reserver la branche la plus à gauche et de plus petite taille, le
chemin résultant est [1]. Ensuite, l'opération (W, 1) est transformée en
\textsc{insert}($i_Q$, W, $\dashv$) résultant sur le chemin [2] etc.  Dans ce
cas, la profondeur de l'arbre n'augmente jamais. À cet égard, la stratégie
employée est très efficace. Cependant, elle n'est pas totalement optimale
puisque l'arbre est prévu pour accueillir 8 identifiants lorsque seulement 6
sont alloués.

\begin{wrapfigure}{r}{0.5\textwidth}
  \vspace{-10pt}
  \centering
  \input{input/replication/allocpathexampleB.tex}
  \caption{\label{repl:fig:allocpathexampleB}Allocation pire-cas}
  \vspace{-10pt}
\end{wrapfigure}

\textbf{Second cas :} De la même manière, l'opération d'insertion (Y, 0) est
transformée en \textsc{insert}($\vdash$, Y, $\dashv$) dont le résultat est le
chemin [1]. Lors de l'insertion (T, 0), un chemin est requis entre la borne
virtuelle du début de séquence [0] et la borne du caractère 'Y' [1]. Ainsi, la
profondeur du chemin doit augmenter de telle sorte que le nouvel identifiant
muni de l'ordre total $(\mathcal{I},\,<_\mathcal{I})$ soit placé entre les
deux. Considérons un ordre lexicographique, le chemin résultant est [0.X] où X
est choisi entre 0 et 10. Suivant la stratégie, le chemin est [0.1] pour la
lettre 'T'. Puis [0.0.1] pour la lettre 'R' etc. La taille des chemins alloués
augmente très rapidement.  La stratégie d'allocation s'avère inéfficace dans ce
cas.

Cet exemple montre à quel point l'ordre d'insertion des éléments affecte la
longueur des chemins alloués. Malheureusement, ni la séquence d'édition, ni sa
taille ne sont connues par avance.  Passer d'indices locaux mutables et optimaux
d'une séquence classique à des identifiants non-mutable de taille variable d'une
séquence répliquée a un coût qu'il est nécéssaire d'analyser afin de proposer
une fonction d'allocation efficace.

\begin{itemize}
\item [\textbf{Logoot~\cite{weiss2009logoot, weiss2010collaborative,
      weiss2010logootundo} :}] représente originellement ses identifiants sous
  forme de liste sans les factoriser sous forme d'arbre. Cette représentation
  possède l'avantage de fournir un accès instantané à ses éléments au prix d'une
  consommation en espace élevée. En effet, la traduction d'une opération locale
  $\textsc{insert}(element,\, index)$ à
  $\textsc{insert}(id_{pr\acute{e}cedent},\, element,\, id_{suivant})$
  s'effectue en temps constant. D'un autre coté, les identifiants possèdent des
  chemins dont chaque élément est un entier encodé sur 64 bits correspondant à
  une arité de $2^{64}$ dans le modèle d'arbre. Un chemin dans $\mathcal{P}$ est
  donc une succession d'entiers compris entre 0 et $(2^{64}-1)$ :
  $\mathbb{N}_{<2^{64}}.\mathbb{N}_{<2^{64}}\ldots\mathbb{N}_{<2^{64}}$.
  L'ordre total utilisé pour recouvrer la séquence d'éléments est un ordre
  lexicographique. Ayant fait l'assomption que les documents étaient édités de
  gauche à droite, la stratégie s'avère inefficace lorsque le comportement
  d'édition va à l'opposé de cette hypothèse. Le pire cas est déjà illustré dans
  la figure~\ref{repl:fig:allocpathexampleB}. La complexité spatiale de chaque
  identifiant est linéaire, en résulte une complexité quadratique par rapport à
  la taille du document.
\item [\textbf{Logoot split~\cite{mehdi2014merging} :}] étend Logoot lui offrant
  la possibilité d'adapter la granularité de l'élément ciblé. Bien que tous les
  exemples précédent fassent mention de caractères comme éléments de la
  séquence, Logoot peut fixer la granularité à la ligne, ou au paragraphe, ou à
  la section etc. Cette extension prend pour granularité la chaine de caractère
  avec la liberté de la séparer si besoin est. Le nombre d'identifiants à
  allouer s'en trouve diminué, et par conséquent, le traffic généré aussi.
\item [\textbf{Treedoc~\cite{letia2009crdts, preguica2009commutative} :}]
  représente le document sous forme d'arbre binaire avec parcours infixe.
  Ainsi, si l'on considère un élément 'W' dont le chemin est [0], alors un
  élément 'Q' dont le chemin est [0.0] précède 'W', et un élément 'E' dont le
  chemin est [0.1] succède 'W'. En d'autres termes, suffixer le chemin d'un 0
  signifie \emph{à gauche de}, et suffixer le chemin d'un 1 signifie \emph{à
    droite de}. Tout comme l'approche Logoot, les observations effectuées sur un
  corpus Wikipédia montre l'importance d'une fonction d'allocation gérant
  l'édition de gauche à droite. Elles conduisent à proposer une heuristique
  selon laquelle des nœuds de l'arbre sont virtuellement créés en prévoyance des
  éditions à venir. Toutefois, le problème demeure lorsque le comportement
  d'édition ne coopère pas. L'identifiant peut être de taille linéaire comparée
  à la taille du document.
\end{itemize}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../paper"
%%% End:
