
\section{OT ou CRDTs?}
\label{repl:sec:otorcrdts}

La réplication optimiste permet de répliquer les données et d'effectuer des
modifications sur celle-ci directement, sans accord préalable d'un cœur
décisionnel. Les données sont deviennent à la fois plus disponibles et plus
réactives. Toutefois, les approches qui appartiennent à ce schéma de réplication
ont devoir de fournir des opérations de modification respectant la cohérence
forte à terme -- convergeant si possible vers un état
non-arbitraire. Malheureusement, cela peut s'avérer plus honéreux qu'il n'y
parait. Cette section décrit deux familles d'approches, respectivement les
approches à transformés opérationnels (OT -- cf. §\ref{repl:subsec:ot}) et les
approches à structure de données sans résolution de conflits (CRDTs --
cf. §\ref{repl:subsec:crdts}), ainsi que leurs limitations.

\subsection{Transformés opérationnels}
\label{repl:subsec:ot}

Les approches basées sur les transformés opérationnels~\cite{sun1998operational,
  sun2009contextbased} (OT) sont les plus anciennes et s'appliquent à un large
champs d'applications telles que l'édition de texte, l'édition d'images
etc. L'intuition est simple : Lors de la réception d'opérations modifiant notre
réplique, les arguments en sont ajustés afin qu'ils s'appliquent à l'état actuel
de la réplique, indépendemment des opérations effectuées entre temps.

\begin{figure}
  \centering
  \input{./input/replication/otexample.tex}
  \caption{\label{repl:fig:otexample} Exemple de transformé
    opérationnel. L'opération de suppression des 3 premiers caractères sur la
    réplique 3 ('RTY') est transformée afin de supprimer les 3 derniers caractères
    sur les autres répliques.}
\end{figure}

La figure~\ref{repl:fig:otexample} illustre le principe de fonctionnement des
approches basées sur les transformés opérationnels sur un scenario impliquant
une séquence répliquée. Dans cet exemple, les répliques sont toutes initialisées
avec la séquence 'RTY'. Ensuite, tandis que sur la réplique 1 trois caractères
supplémentaires sont insérés en tête pour obtenir 'QWERTY', sur la réplique 3
sont supprimés les trois caractères pour obtenir la séquence vide. Lors de la
réception de cette dernière opération de suppression au niveau de la réplique 1,
elle est interprétée comme une opération dont le contexte d'exécution n'avait
pas encore intégré les insertions -- et donc pas décalé les indices des
caractères. À ce titre, l'argument de l'opération se voit reattribué sa cible
aux trois caractères à partir du troisième caractère non-inclu. Réciproquement,
la réplique 3 intègre les insertions faites sur la réplique 1. Toutefois aucun
changement n'est nécessaire. À terme, les répliques convergent vers la séquence
'QWE'.

Dans le cadre de l'édition de texte, en plus des usuelles opérations d'insertion
et de suppression, OT founit des opérations ciblant les chaînes de caractères
telles que le déplacement, le couper -- coller, etc. Toutefois, l'analyse de
correction nécessite d'examiner chaque couple d'opérations ainsi que leurs
paramètres. En conséquence, lors de l'écriture du
papier~\cite{imine2003proving}, peu d'approches étaient réellement correctes.
Les approches OT peuvent être divisées en deux classes :
\begin{itemize}
\item [\textbf{Les approches décentralisées~\cite{sun2009contextbased} :}]
  Chaque client est aussi un serveur hébergeant une réplique
  (cf. figure~\ref{repl:fig:otexample}). Chacune de ces entités doit être en
  mesure d'effectuer les transformations d'elle-même. Parmi les prérequis à
  cette tâche figure le méchanisme de détection de concurrence. En effet,
  retrouver le contexte d'exécution revient à transformer l'opération reçu
  contre toutes celles qui ont été intégrées sans avoir connaissance de
  celle-ci. Malheureusement, cela requière le transport d'un vecteur
  d'horloges~\cite{lamport1978time} -- ou consort -- avec chaque opération, qui
  sont ensuite sauvegardés dans un historique d'opérations. Que ce soit en terme
  de nombre d'utilisateurs ou en terme de nombre d'opérations, ces approches
  passent difficilement à l'échelle. Le temps d'exécution d'une opération locale
  est insignifiant, mais tout le reste des participants souffrent de quelques
  opérations concurrentes.

  Du reste, dans un environnement bien maitrisé, où les opérations arrivent très
  rapidement à un groupe raisonnable de participants, alors ces approches
  décentralisées deviennent inconcurrençables~\cite{mehdi2014merging}.
\item [\textbf{Les approches centralisées~\cite{nichols1995high} :}] Elles
  utilisent un serveur central afin de réarranger et diffuser les opérations de
  tous les participants à tous les participants. La transformation s'en trouve
  beaucoup moins coûteuse dès lors qu'un serveur s'interpose dans le
  processus. Toutefois, la topologie elle-même implique plusieurs défauts, à
  savoir, des problèmes concernant la confidentialité -- celui à qui appartient
  le serveur possède les données -- des problèmes concernant le passage à
  l'échelle -- le serveur supporte la charge de tous les participants -- des
  problèmes de tolérance aux pannes -- le serveur constitue un point individuel
  de défaillance.

  Malgré tous ces défauts, les approches centralisées sont les plus courantes
  aujourd'hui avec, notamment, les éditeurs collaboratifs bien connus tels que
  Google Docs (\REF) ou Etherpad (\REF).
\end{itemize}

\subsection{Structure de données sans résolutions de conflits}
\label{repl:subsec:crdts}

Un conflit est un cas où une valeur particulière est modifiée en même temps à
des endroits différents. Par exemple, la figure~\ref{repl:fig:optimisticexample}
montre un conflit sur le choix de la couleur. Les auteurs des modifications
ayant pris connaissance de ce conflit peuvent s'arranger afin de ne garder que
l'une des valeurs. Dans tous les cas, la résolution de conflits prend du temps,
est susceptible d'engendrer des erreurs, ou d'autres conflits en cascade.

Les structures de données sans résolution de
conflits~\cite{shapiro2011comprehensive} (CRDTs) appartiennent au schéma de
réplication optimiste. Comme leur dénomination l'indique, ces approches sont
basées sur des structures de données abstraites fournissant des opérations dont
les résultats commutent, et donc, ne générent pas de conflits, même en cas de
concurrence.  Il en existe deux familles équivalentes mais proposant un
compromis différent :
\begin{itemize}
\item [\textbf{Basée sur l'état :}] Lors d'une opération, l'état local change et
  est envoyé en totalité aux autres répliques qui fusionnent alors l'état reçu
  et leur état propre. L'envoi d'un état est honéreux et doit être effectué avec
  parcimonie. En revanche, puisqu'il est autonome (\emph{self-contained}), il ne
  nécessite aucune garantie particulière quant aux moyens de diffusion.
\item [\textbf{Basée sur les opérations :}] Lors d'une opération, son résultat
  seul est envoyé aux autres répliques où il est intégré. Les résultats sont
  envoyés les uns après les autres ce qui s'avère beaucoup moins coûteux que
  l'état complet. En revanche, cela requière une diffusion fiable, i.e., toutes
  les opérations doivent être inéluctablement reçues par tous les serveurs
  hébergeant une réplique.

  Les opérations doivent être commutatives
  ($o_1 \times o_2 \Leftrightarrow o_2 \times o_1$), associatives
  ($(o_1 \times o_2) \times o_3 \Leftrightarrow o_1 \times (o_2 \times o_3)$) et
  idempotentes ($o_1 \times o_1 \Leftrightarrow o_1$).
\end{itemize}

Des CRDTs existent pour différent types de structures tels que les compteurs,
les ensembles, les graphes etc.\\
{\noindent%
\begin{minipage}[t]{0.48\textwidth}
  \begin{algorithm}[H]
    \input{input/replication/counteralgoA.tex}
    \caption{\label{repl:algo:counterA} Counter using set.}
  \end{algorithm}
\end{minipage}%
\hfill%
\begin{minipage}[t]{0.48\textwidth}
  \begin{algorithm}[H]
    \input{input/replication/counteralgoB.tex}
    \caption{\label{repl:algo:counterB} Counter using vector.}
  \end{algorithm}
\end{minipage}
}

Les algorithmes~\ref{repl:algo:counterA} et~\ref{repl:algo:counterB} décrivent
le squelette des algorithmes CRDTs décomposé selon le schéma de réplication
optimiste, à savoir les mises à jours locales modifiant directement la réplique
locale, et les mises à jours reçues.

L'algorithme~\ref{repl:algo:counterA} présente une première façon d'implémenter
un CRDT pour compteur basé sur les opérations. Celle-ci associe un identifiant
unique -- composé de l'identité unique du serveur et d'un compteur local -- à
chaque opération d'incrémentation. Dans le cas du compteur n'autorisant que les
incrémentations, ces identifiants seuls permettent de garantir l'idempotence
pour peu qu'ils soient enregistrés. Ainsi, un ensemble enregistre les
identifiants des opérations. En cas de double réception dûe aux aléas du réseau,
la seconde intégration est sans effets. L'ordre de réception des opérations est
sans importance puisque l'effet de l'unique opération possible est toujours le
même. Lire la valeur courante de ce compteur revient à effectuer le cardinal de
l'ensemble des identifiants.

Cette approche est simple mais ne tire pas profit de la redondance
d'informations contenue dans les identifiants. En particulier, si un serveur
génère un identifiant $\langle n,\, c\rangle$ c'est qu'il fût incrémenté $c-1$
fois par le passé. Ainsi, seule la plus haute valeur
compte. L'algorithme~\ref{repl:algo:counterB} montre les instructions d'un tel
compteur. À la différence du premier algorithme, la structure utilisée est un
vecteur d'entrées où chaque site se voit attribué son compteur connu. La valeur
du compteur est alors la somme des compteurs de ce vecteur.

La complexité en communication des deux algorithmes est identique : Elle est
constante. La complexité en temps est identique sauf pour la fonction
\textsc{query} où le second algorithme itère sur les identifiants du vecteur
afin de retourner la valeur du compteur. Toutefois, au prix d'un entier
supplémentaire pour sauvegarder la taille totale, les complexités temporelles
sont équivalentes. Enfin, lorsque le premier algorithme possède une complexité
spatiale bornée linéairement au nombre d'incrémentations, le second algorithme
possède une complexité spatiale bornée linéairement au nombre de sites. Par
conséquent, l'algorithme~\ref{repl:algo:counterB} domine
l'algorithme~\ref{repl:algo:counterA}. La section~\ref{repl:sec:sequences}
décrit les approches CRDTs destinées aux séquences. Hélas, l'analyse en
complexité s'avère plus difficile et souvent moins tranchée que dans l'exemple
des compteurs.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../paper"
%%% End:
