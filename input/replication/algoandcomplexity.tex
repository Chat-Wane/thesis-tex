
\section{Algorithmes et complexité}

\TODO{Introduction}

\subsection{Lien arbre -- séquence}

La structure de données répliquée est un arbre mais l'objet manipulé par
l'utilisateur est une séquence. Il est donc nécessaire de fournir les
fonctionnalités d'accès élémentaires afin de faire le lien entre l'arbre et la
séquence.
\begin{inparaenum}[(i)]
\item La fonction \textsc{get} permet d'obtenir l'identifiant à une position
  donnée dans la séquence (cf. §\ref{repl:subsec:get}).
\item La fonction \textsc{indexOf} permet d'obtenir la position d'un
  identifiant (cf. §\ref{repl:subsec:indexof}).
\end{inparaenum}

\subsubsection{get}
\label{repl:subsec:get}

\begin{wrapfigure}{r}{0.6\textwidth}
  \vspace{-35pt} %% (ugly)
  \begin{minipage}[t]{0.6\textwidth}
    \begin{algorithm}[H]
      \input{input/replication/getalgo.tex}
      \caption{\label{repl:algo:get} Get.}
    \end{algorithm}
  \end{minipage}
  \vspace{-15pt}
\end{wrapfigure}

L'algorithme~\ref{repl:algo:get} présente les instructions de la fonction
\textsc{get} permettant d'obtenir l'identifiant présent à une position donnée
dans la séquence. Celle-ci est nécéssaire lorsque un élément est localement
inséré ou supprimé. En particulier, elle permet de retrouver les identifiants
des éléments adjacents à la position d'insertion. Ces derniers seront ensuite
utilisés afin d'allouer un nouvel identifiant unique.

Afin de retrouver l'identifiant à la position $index$ de la séquence, l'arbre
est parcouru en largeur (cf. ligne~\ref{repl:line:lefttoright}) fixé
arbitrairement de gauche à droite.  Puisque chacun des noeuds sauvegarde le
nombre total de fils qu'il possède, il n'est pas nécessaire de parcourir
l'ensemble des feuilles de l'arbre précedant la position recherchée. Toutefois,
selon la fonction de parcours utilisée pour retrouver la position et la séquence
d'édition ayant rempli la structure, les performances peuvent varier.

\begin{figure}
  \centering
  \input{input/replication/getexample.tex}
  \caption{\label{repl:fig:getexample} Exemple de parcours effectué lors de la
    recherche de l'identifiant en position 5 correspondant au caractère 'Y'.}
\end{figure}

La figure~\ref{repl:fig:getexample} montre un exemple de recherche d'identifiant
dans un arbre représentant la séquence 'QWERTY'. La recherche concerne la
position $5$ correspondant au caractère 'Y'. L'arbre est parcouru en partant du
fils gauche de la racine. Ce fils sait que ses sous-branches contiennent 3
caractères. L'algorithme en déduit que le prochain fils de la racine est à la
position 4. En examinant ce second fils, l'algorithme déduit que l'identifiant
recherché est inclue dans l'un de ses fils. Ainsi, il continue l'exploration
dans ce sous-arbre. Lorsqu'il examine le noeud contenant 'Y', il sait que
celui-ci est en position $5$. Par conséquent, il retourne le chemin qu'il a
empreinté pour y parvenir, à savoir [5.4]. Nous pouvons observer dans cet
exemple que si la recherche était parti de la droite, elle n'aurait eu à
parcourir qu'un seul élément intermédiaire (contenant le caractère 'T'), et
aurait donc été plus efficace.


\begin{wraptable}{r}{0.5\textwidth}
  \input{input/replication/gettable.tex}
  \caption{\label{repl:table:get} Borne supérieure de la complexité temporelle de la fonction \textsc{get} où $I$ est la taille du document.}  
\end{wraptable}

La complexité temporelle de cet algorithme dépend de la séquence d'édition ayant
permit de remplir l'arbre. Ainsi, lorsque l'arbre est rempli aléatoirement, sa
profondeur est faible et un grand nombre d'éléments peuvent être passés. En
revanche, lorsque le comportement d'édition ayant rempli l'arbre est monotone,
une branche de l'arbre seulement est fortement remplie. L'algorithme doit la
parcourir afin de trouver l'identifiant à la position désirée. La complexité est
alors linéaire et correspond au pire cas. Cela s'avère problématique puisque
celle-ci est appelée deux fois par insertion locale. Heureusement, lorsque le
comportement d'édition est monotone, il est facile de se souvenir des bornes
d'insertion : l'une ne change jamais, et l'autre correspond à l'identifiant
nouvellement inséré. Si le comportement d'édition change, l'arbre commence à se
rééquilibrer et les performances se rapprochent de celles de l'édition
aléatoire.


\subsubsection{indexOf}
\label{repl:subsec:indexof}

\begin{wrapfigure}{r}{0.6\textwidth}
  \vspace{-35pt} %% (ugly)
  \begin{minipage}[t]{0.6\textwidth}
    \begin{algorithm}[H]
      \input{input/replication/indexofalgo.tex}
      \caption{\label{repl:algo:indexof} indexOf.}
    \end{algorithm}
  \end{minipage}
  \vspace{-15pt}
\end{wrapfigure}

L'algorithme~\ref{repl:algo:indexof} présente les instructions de la fonction
\textsc{indexOf}. Celle-ci sert essentiellement à placer les éléments réçus dans
la séquence perçue par l'utilisateur.  Celle-ci est divisée en trois :
\begin{inparaenum}[(i)]
\item La fonction \textsc{getIndexesOf} retourne les indices successifs dans les
  listes triées constituants les fils des nœuds de l'arbre. Celle-ci utilise la
  fonction \textsc{binaryIndexOf} possédant un compléxité temporelle
  logarithmique comparée à la taille du tableau trié parcouru.
\item La fonction \textsc{getSum} parcours l'arbre afin d'en déduire l'indice de
  séquence correspondant. Afin de ne pas avoir à parcourir l'entièreté des
  branches, les noeuds sauvegardent le nombre de sous-branches qu'ils possèdent
  (similairement à l'algorithme~\ref{repl:algo:get}).  La
  ligne~\ref{repl:line:optimization} définit la façon dont l'arbre est
  parcouru. Un optimisation consiste à parcourir l'arbre à partir de la borne la
  plus proche de l'indice à la profondeur concernée.
\item La fonction \textsc{indexOf} est composée des deux fonctions
  susmentionnées.
\end{inparaenum}

\TODO{Figure explaining the operation.}

La complexité temporelle de cette fonction est proche de celle de la fonction
\textsc{get} car basée sur le même principe. La seule différence est le surcoût
logarithmique lié à la recherche dichotomique à chaque niveau de l'arbre. Encore
une fois, les complexités linéaires ne sont pas problématiques car ces
opérations peuvent être effectuées en arrière-plan. De plus, l'utilisateur
possède une vue partielle du document. Si les mises à jour ne tombent pas dans
cette fenêtre, la fonction peut arrêter son éxecution.


\subsection{Modification de la structure}

La structure d'arbre représentant le document réparti se modifie au rythme des
insertions et suppressions effectuées par les utilisateurs, qu'ils soient
distants ou non. 

\subsubsection{insert}


\begin{wrapfigure}{r}{0.6\textwidth}
  \vspace{-35pt} %% (ugly)
  \begin{minipage}[t]{0.6\textwidth}
    \begin{algorithm}[H]
      \input{input/replication/insertalgo.tex}
      \caption{\label{repl:algo:insert} Insert.}
    \end{algorithm}
  \end{minipage}
  \vspace{-15pt}
\end{wrapfigure}

L'algorithme~\ref{repl:algo:insert} présente les instructions de la fonction
d'insertion.


\subsubsection{delete}