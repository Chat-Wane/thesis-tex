
\section{Questions de recherche}

\begin{figure}
  \begin{center}
    \input{input/introduction/architecture.tex}
    \caption[Architecture des éditeurs collaboratifs]
    {\label{intro:fig:architecture} Architecture en 4 couches des éditeurs
      collaboratifs.}
  \end{center}
\end{figure}

L'architecture d'un éditeur collaboratif est constituée de quatre parties
(cf. la figure~\ref{intro:fig:architecture}) :
\begin{inparaenum}[(i)]
\item l'interface homme-machine qui constitue le lien entre l'utilisateur et son
  document, 
\item la structure de données représentant le document partagé,
\item la structure de causalité qui permet d'ordonner les changements effectués
  sur le document,
\item la couche réseau qui permet de disséminer les changements effectués sur le
  document.
\end{inparaenum}

Aucune de ces couches ne doit empêcher le passage à l'échelle de l'application.
Cela concerne aussi bien le nombre d'utilisateurs, la taille des documents, la
fréquence des changements et la durée avant laquelle ils sont intégrés.

Pour un éditeur collaboratif décentralisé, chaque client est aussi un serveur et
participe activement au bon fonctionnement du système. Ainsi, il contribue à la
dissémination des changements effectués sur le document. Pour ce faire, chaque
éditeur possède un ensemble d'éditeurs -- ses voisins -- avec lequel
communiquer. Lorsqu'un éditeur reçoit un changement, il le propage à son propre
ensemble d'éditeurs connus. Les changements parviennent à tous les éditeurs par
transitivité~\cite{birman1999bimodal}.  La taille de cet ensemble est
déterminante. En effet, lorsqu'elle augmente, le trafic généré augmente au
risque de dépasser les capacités d'émission des éditeurs; lorsqu'elle diminue,
les changements risquent de ne plus parvenir à tous les éditeurs.

Afin de configurer la taille de cet ensemble idéalement~\cite{erdos1959random},
le développeur doit connaître le nombre de collaborateurs que l'éditeur doit
supporter. Malheureusement, celui-ci varie, que ce soit pendant la durée de la
collaboration, e.g., un cours de formation en ligne
(\emph{MOOC})~\cite{breslow2013studying} voit sa population fluctuer selon
l'intérêt qu'il suscite; ou entre deux documents, e.g., un document créé pour un
événement de grande ampleur n'a pas la même audience que celle d'un rapport de
projet écrit par des étudiants.

Cela pose la première question de recherche : \textbf{Comment adapter
  efficacement le voisinage de chaque éditeur au nombre fluctuant de
  collaborateurs?}

%%\paragraph{QR A.} \textbf{Afin d'ajuster le trafic à la session d'édition,
%%  comment adapter efficacement le voisinage de chaque éditeur aux fluctuations
%%  des réseaux?}

Afin d'augmenter la disponibilité et la réactivité des documents, les éditeurs
collaboratifs actuels copient les documents chez chaque
client~\cite{saito2005optimistic}, et, lorsqu'une modification est effectuée,
elle est directement appliquée sur leur copie avant d'être envoyée au reste des
éditeurs où elle est intégrée. Un système est correct si, lorsque les même
changements ont été intégrés, les utilisateurs lisent le même
document~\cite{burckhardt2014replicated, shapiro2011conflict}.

L'utilisation des structures de données ``classiques'' telles que les listes
n'est pas directement possible du fait de la latence entre les
collaborateurs. Par exemple, si un auteur insère un caractère en début de
document pendant qu'un autre supprime un caractère au même endroit, le premier
auteur risque, à tort, de voir supprimé le caractère qu'il vient d'insérer. Afin
d'éviter de telles situations, de nouvelles structures et de nouveaux
algorithmes doivent être employés.

Une première famille d'approches consiste à transformer les arguments de
l'opération afin qu'elle considère les opérations intégrées
concurremment~\cite{sun1998operational}. Dans l'exemple précédent, lors de
l'intégration de la suppression par le premier éditeur, celui-ci doit se rendre
compte qu'un caractère a été ajouté en tête concurremment. Il doit donc modifier
les arguments de l'opération reçue afin que le second caractère soit supprimé,
et non plus le premier. Malheureusement, la détection de ces cas nécessite de
transporter des données avec chaque opération dont le coût est
prohibitif~\cite{sun2009contextbased}.

Une seconde famille d'approches consiste à utiliser des structures de données
dont les opérations sont commutatives~\cite{shapiro2011conflict}. Pour que les
opérations commutent, ces approches associent à chaque caractère un identifiant
unique et immuable.

\paragraph{Les identifiants non supprimables~\cite{oster2006data}.} L'opération
de suppression se contente de cacher le caractère à l'utilisateur. Afin de
purger la structure des identifiants cachés et ainsi conserver de bonnes
performances, un protocole de ramasse-miettes
réparti~\cite{abdullahi1998garbage} doit être exécuté
régulièrement. Malheureusement, ceux-ci s'avère extrêmement coûteux.

\paragraph{Les identifiants de taille variable~\cite{weiss2009logoot}.} Les
identifiants sont des listes dont la taille, définie à la génération, peut
grandir très rapidement~\cite{weiss2009logoot}. Cette croissance impacte
négativement les performances du système. Pour y remédier, un protocole de
relocalisation des identifiants doit être exécuté
régulièrement~\cite{zawirskiasynchronous}. Malheureusement, ces protocoles
s'apparentent à l'obtention d'un consensus dans un contexte réparti dont le coût
s'avère également très élevé~\cite{mostefaoui2015signature}.

% Le méchanisme de dissémination des messages fait un usage intensif de ces
% voisinages. Les messages transportés par celui-ci se doivent d'être légers, et
% pourtant porteur de suffisamment d'informations afin de reconstruire des
% documents identiques.

Cela pose la seconde question de recherche : \textbf{Afin d'éviter tout
  protocole additionnel de relocalisation des identifiants, comment allouer ces
  identifiants pour que leur taille soit directement sous-linéaire?}

  % En effet, les auteurs étant distants les uns des autres, les modifications ne
  % sont pas reçues et traitées instantanéments par tous. De ce fait, l'ordre
  % d'application des modifications peut différer parmis les participants. En
  % particulier les modifications concurrentes doivent être soigneusement
  % étudiées. Elles apparaissent lorsque deux auteurs effectuent une modification
  % sans avoir connaissance de celle de leur homologue. Puisqu'aucune ne précède
  % l'autre, elles peuvent être appliquées dans n'importe quel ordre. Toutefois,
  % les structures doivent toujours converger vers un état équivalent. Contraindre
  % l'ordre d'application des opérations s'avère hélas extrêmement coûteux.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../paper"
%%% End:
