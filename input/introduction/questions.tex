
\section{Questions de recherche}

\begin{figure}
  \centering
  \input{input/introduction/architecture.tex}
  \caption{\label{intro:fig:architecture} Architecture en 4 couches des éditeurs
    collaboratifs.}
\end{figure}

L'architecture d'un éditeur collaboratif est constituée de quatres parties
(cf. la figure~\ref{intro:fig:architecture}) :
\begin{inparaenum}[(i)]
\item l'interface homme-machine qui constitue le lien entre l'utilisateur et son
  document, 
\item la structure de données représentant le document partagé,
\item la structure de causalité qui permet d'ordonner les changements sur le
  document,
\item la couche réseau qui permet d'envoyer et recevoir les changements sur le
  document.
\end{inparaenum}

Aucune de ces couches ne doit empêcher le passage à l'échelle de l'application.
Cela concerne aussi bien le nombre d'utilisateurs, que la taille des documents,
que la fréquence des changements ainsi que la durée avant laquelle ils sont
intégrés.

\begin{itemize}
\item [\textbf{QR.}] \textbf{Comment proposer un éditeur collaboratif temps réel
    dont l'accès et le déployement soit aussi simple que sur le Nuage, dont les
    performances passent à l'échelle, dont l'usage ne dépende d'aucune autorité
    centrale?}
  
  La première partie de cette question met en lumière la force du Nuage à
  fournir des services dont l'utilisation et la configuration sont
  aisées. L'accès à ces services inclut bien souvent une interface web
  accessible grâce aux navigateurs Internet. Le fait que ces derniers soient
  présents dans quasiment tous les appareils communiquants modernes participe à
  l'hégémonie actuelle du Nuage : malgré l'hétérogénéité des appareils utilisés,
  une simple URL (\emph{Uniform Resource Locator}) permet d'accèder aux services
  quel que soit la localisation. L'expérience utilisateur ne dépend plus alors
  que de la conception d'un site web adaptatif (\emph{responsive}) aux
  appareils.

  Ce n'est que grâce à la récente introduction de WebRTC~\cite{webrtc} comme
  protocole de communication de navigateur-à-navigateur que les applications web
  réparties et décentralisées sont possibles. Dans le contexte de l'édition
  collaborative, chaque auteur est en mesure d'apporter des modifications au
  document qu'ils partagent. Chacune de ces modifications doit être envoyées aux
  autres auteurs afin qu'ils voient le même document. \TODO{Moar?} Cela
  introduit donc la sous-question suivante:
  \begin{itemize}
  \item [\textbf{QR A.}] \textbf{Quel protocole de dissémination de messages
      utiliser dont les performances passent à l'échelle, dont le bon
      fonctionnement soit résistant aux connexions et déconnexions fréquentes
      (\emph{churn}) possibles dans ce contexte?}    
  \end{itemize}

  Supposons qu'un tel protocole de communication existe. Les messages
  transportées par celui-ci se doivent d'être de petite taille, et pourtant
  suffisamment descriptifs pour réconstruire le même document indépendemment de
  l'auteur recevant le message.
  \begin{itemize}
  \item [\textbf{QR B.}] \textbf{Quelles structures de données et quelles
      algorithmes utiliser dont les performances passent à l'échelle?}
  \end{itemize}
  En effet, les auteurs étant distants les uns des autres, les modifications ne
  sont pas reçues et traitées instantanéments par tous. De ce fait, l'ordre
  d'application des modifications peut différer parmis les participants. En
  particulier les modifications concurrentes doivent être soigneusement
  étudiées. Elles apparaissent lorsque deux auteurs effectuent une modification
  sans avoir connaissance de celle de leur homologue. Puisqu'aucune ne précède
  l'autre, elles peuvent être appliquées dans n'importe quel ordre. Toutefois,
  les structures doivent toujours converger vers un état équivalent. Contraindre
  l'ordre d'application des opérations s'avère hélas extrêmement coûteux.

\end{itemize}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../paper"
%%% End:
