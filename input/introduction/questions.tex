
\section{Questions de recherche}

\begin{figure}
  \centering
  \input{input/introduction/architecture.tex}
  \caption{\label{intro:fig:architecture} Architecture en 4 couches des éditeurs
    collaboratifs.}
\end{figure}

L'architecture d'un éditeur collaboratif est constituée de quatres parties
(cf. la figure~\ref{intro:fig:architecture}) :
\begin{inparaenum}[(i)]
\item l'interface homme-machine qui constitue le lien entre l'utilisateur et son
  document, 
\item la structure de données représentant le document partagé,
\item la structure de causalité qui permet d'ordonner les changements sur le
  document,
\item la couche réseau qui permet d'envoyer et recevoir les changements sur le
  document.
\end{inparaenum}

Aucune de ces couches ne doit empêcher le passage à l'échelle de l'application.
Cela concerne aussi bien le nombre d'utilisateurs, que la taille des documents,
que la fréquence des changements ainsi que la durée avant laquelle ils sont
intégrés.

\begin{itemize}
\item [\textbf{QR.}] \textbf{Quelle combinaison d'éléments permettent la
    construction d'un éditeur collaboratif temps réel dont les performances
    passent à l'échelle et dont le déploiement soit aussi simple que sur le
    Nuage?}
  
  Malheureusement, la couche réseau et la couche structure font actuellement
  obstacle au passage à l'échelle. En effet, les solutions centralisées, où un
  serveur fait office d'intermédiaire entre les clients, posent des problèmes
  \begin{inparaenum}[(i)]
  \item de confidentialité
  \item de censure,
  \item de passage à l'échelle,
  \item de point unique de défaillance.
  \end{inparaenum}
  Seule la décentralisation permet résoudre ces problèmes. Un client est aussi
  serveur et contribue à la disséminations des changements effectués sur le
  document. Pour ce faire, chaque éditeur possède un ensemble d'éditeurs avec
  lequel communiquer. Lorsqu'un éditeur reçoit un changement, il le propage à
  son propre ensemble d'éditeurs connus. Les changements atteignent tous les
  éditeurs par transitivité. La taille de cet ensemble est déterminante. En
  effet, lorsqu'elle augmente, le traffic généré augmente au risque de dépasser
  les capacités de l'appareil émetteur; lorsqu'elle diminue, le réseau risque
  des déconnexions partielles auquel cas les changements ne parviennent plus à
  tous les éditeurs.

  Afin de configurer la taille de cet ensemble idéalement, le développeur doit
  connaitre la taille du réseau. Malheureusement, celles-ci varient, que ce soit
  pendant la durée de vie du réseau, e.g., une cours de formation en ligne
  (\emph{MOOC}) voit sa population varier selon l'interêt qu'il suscite; ou
  entre les réseaux créés par une même application, e.g., un document créé pour
  un événement de grande ampleur n'a pas la même audience que celle d'un rapport
  de projet écrit par des étudiants.

  % La première partie de cette question met en lumière la force du Nuage à
  % fournir des services dont l'utilisation et la configuration sont
  % aisées. L'accès à ces services inclut bien souvent une interface web
  % accessible grâce aux navigateurs Internet. Le fait que ces derniers soient
  % présents dans quasiment tous les appareils communiquants modernes participe à
  % l'hégémonie actuelle du Nuage : malgré l'hétérogénéité des appareils utilisés,
  % une simple URL (\emph{Uniform Resource Locator}) permet d'accèder aux services
  % quel que soit la localisation. L'expérience utilisateur ne dépend plus alors
  % que de la conception d'un site web adaptatif (\emph{responsive}) aux
  % appareils.

  % Ce n'est que grâce à la récente introduction de WebRTC~\cite{webrtc} comme
  % protocole de communication de navigateur-à-navigateur que les applications web
  % réparties et décentralisées sont possibles. Dans le contexte de l'édition
  % collaborative, chaque auteur est en mesure d'apporter des modifications au
  % document qu'ils partagent. Chacune de ces modifications doit être envoyées aux
  % autres auteurs afin qu'ils voient le même document. \TODO{Moar?} Cela
  % introduit donc la sous-question suivante:
  \begin{itemize}
  % \item [\textbf{QR A.}] \textbf{Quel protocole de dissémination de messages
  %     utiliser dont les performances passent à l'échelle, dont le bon
  %     fonctionnement soit résistant aux connexions et déconnexions fréquentes
  %     (\emph{churn}) possibles dans ce contexte?}    
  \item [\textbf{QR A.}] \textbf{Comment disséminer les messages de telle façon
      que le traffic s'adapte automatiquement aux variations des réseaux?}
  \end{itemize}

  Supposons qu'un tel protocole de communication existe. Les messages
  transportées par celui-ci se doivent d'être léger, et pourtant suffisamment
  descriptifs pour réconstruire le même document indépendemment de l'auteur
  recevant le message.

  Afin d'augmenter la disponibilité et la réactivité des documents, les éditeurs
  actuels copient les documents chez chaque client~\cite{saito2005optimistic},
  et, lorsqu'une modification est effectuée, elle est directement appliqué sur
  leur copie avant d'être envoyée au reste des éditeurs où elle est intégrée. Un
  système est correct si, et seulement si, lorsque les même changements ont été
  intégrés, les utilisateurs lisent le même document~\cite{shapiro2011conflict}.

  L'utilisation des structures de données ``classiques'' telles que les listes
  n'est pas directement possible du fait de la latence entre les
  participants. Par exemple, si un auteur insère un caractère en début de
  document pendant qu'un autre supprime un caractère au même endroit, le premier
  auteur risque, à tort, de voir supprimé le caractère qu'il vient
  d'insérer. Afin d'éviter de telles situations, de nouvelles structures et de
  nouveaux algorithmes doivent être employés.

  Une première famille d'approches consiste à transformer les arguments de l'opérations
  afin qu'elle considère les opérations intégrées concurremment (\REF). Dans
  l'exemple précédent, lors de l'intégration de la suppression par le premier
  auteur, l'opération, se rendant compte qu'un caractère a été ajouté en tête,
  aurait modifié ses arguments afin que le second caractère soit supprimé, et
  non plus le premier. Malheureusement, la détection de ces cas nécessite de
  transporter des données avec chaque opération dont le coût est prohibitivement
  élevé. \TODO{Moar?}

  Une seconde famille d'approches (\REF) consiste à utiliser des structures de
  données dont les opérations sont commutatives. Pour que les opérations
  commutent, ces approches associent à chaque caractère un identifiant unique et
  immuable. Toutefois, ces identifiants sont
  \begin{inparaenum}[(i)]
  \item soit indestructibles \TODO{Moar.};
  \item soit des listes dont la taille est définie à la génération et peut
    grandir très vite. \TODO{Moar.}
  \end{inparaenum}

  \begin{itemize}
  \item [\textbf{QR B.}] \textbf{Comment allouer des identifiants dont la taille
      soit sous-linéaire?}
  \end{itemize}
  % En effet, les auteurs étant distants les uns des autres, les modifications ne
  % sont pas reçues et traitées instantanéments par tous. De ce fait, l'ordre
  % d'application des modifications peut différer parmis les participants. En
  % particulier les modifications concurrentes doivent être soigneusement
  % étudiées. Elles apparaissent lorsque deux auteurs effectuent une modification
  % sans avoir connaissance de celle de leur homologue. Puisqu'aucune ne précède
  % l'autre, elles peuvent être appliquées dans n'importe quel ordre. Toutefois,
  % les structures doivent toujours converger vers un état équivalent. Contraindre
  % l'ordre d'application des opérations s'avère hélas extrêmement coûteux.

\end{itemize}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../paper"
%%% End:
