
\section{Perspectives}
\label{conclu:sec:perspectives}

Les travaux réalisés lors de cette thèse et présenté dans ce manuscrit offrent
de nombreuses perspectives de différente granularité. Tout d'abord, chacun des
composants de notre éditeur collaboratif peut être amélioré ou étendu. Ensuite,
l'éditeur lui-même offre des opportunités inédites. Par exemple, son
intégration, non en opposition, mais en complément des approches actuellement
centralisés. Enfin, l'architecture ouvre aussi la voie à un plus large champs
d'applications décentralisées directement accessibles via les navigateurs web.

Cette section fournit une liste non-exhaustive de perspectives scientifiques
concernant ces travaux de thèse.

\subsection{Fusion de réseaux}

\label{conclu:subsec:merging}

La fusion de réseaux consiste à obtenir un réseau unique comme l'union des
membres de plusieurs réseaux. Le réseau obtenu doit hériter des propriétés de
ses parents.  Lors de ce processus, nous supposons qu'au moins un des nœuds
appartenant à l'un des réseau contacte l'autre réseau afin d'initier la
fusion. Grâce à la connexion qui en résulte, les réseaux sont à même de
communiquer, et donc de fusionner.

Les approches à taille fixe sont triviales à étendre : les mélanges périodiques
suffisent à garantir un réseau connexe. Si toutefois les vues partielles sont
configurées avec des tailles différentes, il suffit alors de prendre la taille
maximum des deux. Par exemple, un nœud avec une vue partielle de 5 voisins verra
sa vue augmenter à $7$ voisins après un échange avec le nœud dont la vue
partielle est peuplée de $7$ références.

\SPRAY est une approche dont les vues partielles évoluent automatiquement en
réaction aux entrées et sorties du réseau. En particulier, les vues partielles
suivent une progression logarithmiques comparée à la taille du réseau. La fusion
de réseaux \SPRAY doit résulter en un réseau \SPRAY garantissant de même.

La première solution qui vient à l'esprit est la suivante : chacun des nœuds du
premier réseau utilise le contact afin de rejoindre le second réseau, comme un
sablier dont les grains passent un tube étroit pour rejoindre l'autre bulbe sous
l'effet de la gravité. Malheureusement, cette solution est extrêmement lente --
puisque la majorité des nœuds ignorent encore qui est le contact -- et
susceptible d'échouer -- puisque le contact est un point unique de défaillance.

Un seconde solution consiste simplement, à l'instar des approches à taille fixe,
à laisser le mécanisme de mélange faire son office. Petit à petit, d'autres
ponts entre les réseaux vont se former jusqu'à ce que les deux réseaux soient
indifférenciés. Malheureusement, les arcs ne suivent pas l'augmentation relative
au réseau.

\begin{problem}
  Soit $\mathcal{N}_1,\, \mathcal{N}_2,\, \ldots ,\, \mathcal{N}_k$ des réseaux
  de taille arbitraire. On a :
\begin{equation}
  \sum\limits_{i \in \mathbb{N}_{<k}} |\mathcal{N}_i|\ln (|\mathcal{N}_i|) < (\sum\limits_{i \in \mathbb{N}_{<k}} |\mathcal{N}_i|)\ln{(\sum\limits_{i \in \mathbb{N}_{<k}} |\mathcal{N}_i|)}
\end{equation}
Comment adapter les nombres d'arcs effectif (à gauche) pour qu'il atteigne le
nombre d'arcs requis (à droite)?
\end{problem}


% Pour répondre à ce problème, chacun des nœuds appartenant aux réseaux impliqués
% dans la fusion doit être capable de
% \begin{inparaenum}[(i)]
% \item détecter lorsqu'un nouveau réseau fusionne avec celui dans lequel il se
%   trouve (cf. §\ref{net:subsec:detection}),
% \item détecter lorsqu'il a glané suffisamment d'informations pour procéder à la
%   fusion (cf. §\ref{net:subsec:activation}),
% \item ajuster sa vue partielle en conséquence (cf. §\ref{net:subsec:merging}).
% \end{inparaenum}

\subsection{Table de hachage répartie}

Une table de hachage répartie (DHT) est un système permettant de retrouver une
information rapidement dans un réseau de machines. Pour ce faire, l'information
recherchée possède une clé dans laquelle figure des données suffisantes à
l'exploration efficace du réseau. Le réseau est généralement organisé selon un
critère de proximité de clé et constitue un réseau superposé. 

Parmi les représentants des DHT on nomme Chord~\cite{stoica2001chord},
CAN~\cite{ratnasamy2001scalable}, Pastry~\cite{rowstron2001pastry},
Tapestry~\cite{zhao2006tapestry}, Kademlia~\cite{maymounkov2002kademlia}, ou
Kelips~\cite{gupta2003kelips}.  \TODO{Toutes ces approches fournissent un vue
  partielle dont la taille est logarithmique.} Toutefois, tout comme pour les
protocoles d'échantillonnage aléatoire de pairs dont la vue partielle est fixe,
tel que \CYCLON, la taille de leur vue est configurée \emph{a priori} afin que
le système puisse accueillir un ensemble suffisamment large de clés.

\begin{figure}
  \begin{center}
    \input{input/conclusion/dhtexample.tex}
    \caption[Table de hachage répartie]
    {\label{conclu:fig:dhtexample}Table de hachage répartie suivant le principe
      de Chord.}
  \end{center}
\end{figure}

Comme le montre la figure~\ref{conclu:fig:dhtexample}, l'idée est alors de
placer les systèmes classiques de DHT -- ici Chord -- afin qu'ils s'accordent
avec la vue partielle fournie par \SPRAY. Par exemple, si un nœud \SPRAY possède
3 voisins, le réseau superposé en charge de la DHT possède lui aussi 3
voisins. Toutefois, ces derniers sont choisis selon la distance à laquelle ils
se trouvent. Un premier voisin serait celui qui est le plus proche, le second
voisin celui qui se trouve à la moitié de la distance maximum, et le troisième
se trouve à un tiers de la distance maximum. Un tel système permet de diriger les
messages ciblant un nœud particulier très efficacement : de l'ordre de
$\log\log N$ redirections, où $N$ est le nombre de membres du réseau. Grâce à
\SPRAY, cette propriété pourrait rester vraie quelle que soit la taille du
réseau.

% \subsection{Sécurité}

% Les protocoles d'appartenance à un réseau font face à des problèmes de sécurités
% inhérents aux protocoles ciblant de larges dimensions. 

\subsection{Compromis causalité et concurrence}

\CRATE comprend une couche dédiée à la détection de relations causales. La
structure utilisée est celle d'un vecteur d'horloges avec des
exceptions. Celle-ci, similairement aux vecteurs d'horloges, stockent un entier
par participants. Pour les dispositifs informatiques aux configurations plus
modestes tels que les téléphones portables, la progression linéaire de ces
vecteurs peut poser problème. 

Une perspective possible serait de remplacer ce vecteur d'horloges de taille
$N$, où $N$ est le nombre de membres ayant jamais participé à la session
d'édition, par un vecteur d'horloges de taille $K$, où $K$ est un entier
nettement inférieur à $N$. L'intuition derrière cette structure provient du
fait que lorsqu'il n'y a pas de concurrence, une seule horloge de Lamport suffit
pour caractériser la causalité. Si la concurrence augmente, alors des doublons
peuvent apparaître. L'intégration, en présence de doublons, peut conduire à des
incohérences.

L'idée serait alors d'avoir un vecteur s'ajustant à la concurrence du système
afin de borner la fréquence des erreurs. À cela s'ajouterait un mécanisme de
recouvrement sur erreur afin d'intégrer l'opération arrivée en retard (similaire
aux transformées opérationnelles mais étendu aux opérations non-concurrentes).
Enfin, rendre le système fiable -- tous les messages parviennent à tous les
participants -- nécessiterait un mécanisme d'anti-entropie sur cette structure.

\subsection{Wiki réparti temps réel}

Les Wiki sont des espaces de collaborations permettant à plusieurs participants
d'éditer des pages à tour de rôle, i.e., l'édition n'est pas effectuée en temps
réel. Le succès de l'encyclopédie Wikipédia n'est plus à démontrer. Hélas, le
modèle même d'édition provoque l'apparition de conflits. Ces conflits ne
concernent pas seulement des points de vue divergents, mais aussi des éditions
placées aux même endroit dans le document au même moment. Les conflits doivent
être résolus manuellement ce qui constitue une tâche compliquée, à tel point que
les discussions quant à l'organisation de l'écriture ont énormément augmenté au
cours du temps.

Autoriser l'édition temps réel des pages de Wiki permettrait à différent
utilisateurs de voir les modifications effectués par d'autres collaborateurs
afin d'agir en conséquence. Dans ce cas, les seuls conflits restants sont ceux
d'ordre sémantique.

De plus, décentraliser ces sessions d'édition temps réel permet de soulager le
fournisseur du service des coûts liés à l'édition. Les membres d'une session
d'édition participent seuls au bon fonctionnement de la session. Une fois le
travail accompli, le document est sauvegardé sur le serveur et versionné
normalement. Globalement, seul le stockage final reste de sa responsabilité.

Enfin, \CRATE permet de placer des liens à d'autres sessions d'édition dans le
document. Ce simple mécanisme permet de naviguer d'un document à l'autre, d'une
session d'édition à l'autre, et plus généralement d'un réseau à un autre. Il est
alors possible de naviguer très simplement parmi ces réseaux, pour peu qu'ils
soient encore vivants et accessibles.

% Certains projets, comme \emph{The Fold}
% bénéficient d'une foule de gens volontaires qui mettent leur machine à
% disposition afin d'améliorer la puissance calculatoire du système.

\subsection{O'Browser, Where Art Thou?}

De nos jours, les navigateurs web sont plus que de simples visualisateurs de
contenu, ils sont presque devenus des systèmes d'exploitation. Ils comptent
parmi les programmes les plus distribués de par le monde. Ils apparaissent dans
un large éventail d'appareils aux diverses capacités tels que les mobiles, les
tablettes, ou les ordinateurs de bureaux.

Développer une application web, c'est développer pour une large audience
hétérogène.  L'éditeur collaboratif temps réel \CRATE prouve qu'il est possible
de développer des applications décentralisées directement dans le navigateur
web. Un autre exemple d'application décentralisée dans le navigateur est le
projet WebTorrent~\cite{webtorrent} qui permet le transfert de données pair à
pair grâce aux flux directs.

La question est alors simple : \emph{Quelles autres applications décentralisées
  est-il possible de développer?} Et plus généralement, cette question interroge
sur les composants nécessaires afin d'écrire ces applications. Enfin, serait-il
possible d'écrire un langage de programmation permettant de composer les
différents éléments tout en garantissant certaines propriétés sur, par exemple,
le critère de cohérence ou la sécurité. Une telle avancée permettrait de rendre
le web décentralisé, tel qu'il le fut pensé à l'origine.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../paper"
%%% End:
