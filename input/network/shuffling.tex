
\section{Échanger son voisinage}

Au contraire de \CYCLON, \SPRAY mélange des vues partielles dont les tailles
peuvent être différentes. Ce processus à pour but d'équilibrer les tailles de
vue partielles ainsi que de mélanger les références à l'interieur de celles-ci.
Ce processus à pour contrainte de conserver l'exact même nombre d'arcs.

Les deux pairs impliqués dans le mélange s'envoient l'un l'autre la moitié de
leur vue partielle. Après l'intégration de ces nouvelles références, la taille
de leur vue partielle tend vers la moyenne, et la somme globale en demeure
inchangée. Dans ce but, les vues partielles sont des multiensembles. Ainsi, si
un pair réçoit une référence déjà connue, il la conserve en tant que doublon.
De cette façon, le nombre d'arcs reste constant.

Si les doublons ont un impact négatif sur les propriétés du réseau, la plupart
de ceux-ci disparaissent après le processus de mélange. En proportion, ils
deviennent négligeable dès lors que le réseau grandit.

\begin{algorithm}[h]
  \input{./input/network/shufflealgo.tex}
  \caption{\label{net:algo:shuffle}The cyclic protocol of \SPRAY.}
\end{algorithm}

L'algorithme~\ref{net:algo:shuffle} montre la partie periodic de \SPRAY éxécutée
par chaque pair. Il est divisé en deux parties, à savoir le processus actif qui
est appelé régulièrement afin d'initier un mélange de vues, et le processus
passif qui réagit au message du processus actif. Les fonctions qui ne sont pas
explicitement définies sont les suivantes:
\begin{compactitem}
\item $incrementAge(view)$ : incrémente l'âge des éléments présent dans la vue
  $view$ et retourne la vue modifiée.
\item $getOldest(view)$ : retourne le plus vieu des pairs présent dans la vue.
\item $getSample(view,\, size)$ : retourne un échantillon de la vue contenant $size$
  éléments.
\item $replace(view,\,old,\,new)$ : remplace les occurrences de $old$ par $new$ dans
  la vue $view$.
\item $rand()$ : retourne un nombre flottant aléatoire entre $0$ et $1$.
\end{compactitem}

Dans le processus actif, la fonction $loop$ est appelée tous les intervals
$\Delta$ de temps. Tout d'abord, la fonction incrémente l'age de chacun des
voisins dans la vue partielle $\mathcal{P}$. Ensuite, le pair le plus âgé $q$
est choisit afin d'initier un échange. Si le pair $q$ ne peut être joint (car il
est parti ou a crash), alors le pair $p$ éxecute la fonction qui gère ce cas
(voir la section suivante). Ceci est répété jusqu'à ce que $p$ trouve un pair
avec qui communiquer. Ainsi, le vieillissement comme héritage de \CYCLON permet
d'accélérer la suppression des références invalides. Une fois que le pair
initiateur $p$ a trouvé un pair avec qui effectuer l'échange, il selectionne un
échantillon de sa vue partielle tout en excluant la référence à $q$ et en
s'incluant lui-même. La taille de l'échantillon correspond à la moitié de la
taille de la vue partielle avec au minimum $1$ pair : sa propre référence
(cf. Line~\ref{net:line:samplesize}). La réponse de $q$ contient également la moitié
de sa vue partielle. Puisque les pairs ne peuvent apparaitre plusieurs fois dans
$\mathcal{P}$, les pairs impliqués dans le processus d'échange peuvent envoyer
des références cet autre pair ($p$ envoie des références $q$ à $q$). Sans
procédures supplémentaires, ce genre de comportement peut créer des boucles
locales ($q$ a $q$ dans sa vue partielle) ce qui est hautement indésirable. Les
lignes~\ref{net:line:replace1},~\ref{net:line:replace2} permettent de remplacer les
auto-références dans l'échantillon. Enfin, chez les deux pairs, l'échantillon envoyé 
est supprimé de la vue partielle, et l'échantillon réçu est ajouté.

\begin{figure*}
  \centering
  \subfloat[Figure A]
  [Peer $p_6$ initiates the exchange with $p_1$ by sending to the
  latter the multiset $\{p_6,\,p_9\}$.]{
    \input{./input/network/cyclicexampleA.tex}}
  \hspace{40pt}
  \subfloat[Figure B][Peer $p_1$ receives the $p_6$'s message. 
  It sends back the multiset $\{p_2\}$ and adds $\{p_6,\,p_9\}$ to its 
  partial view.]{
    \input{./input/network/cyclicexampleB.tex}}
  \hspace{10pt}
  \subfloat[Figure C][Peer $p_6$ receives the $p_1$'s response, it
  adds $\{p_2\}$ to its partial view.]{
    \input{./input/network/cyclicexampleC.tex}}
  \caption{\label{net:fig:cyclicexample}Example of the \SPRAY's shuffling
    protocol. }
\end{figure*}

La figure~\ref{net:fig:cyclicexample} décrit le méchanisme périodique de \SPRAY. Ce
scénario suit celui de la figure~\ref{net:fig:joiningexample}: le pair $p_1$ vient
de rejoindre le réseau. Le pair $p_6$ initie un échange avec $p_1$ (qui est ici
le plus vieux dans sa vue partielle). $p_6$ choisit
$\left\lceil{|\mathcal{P}_6|\div 2}\right\rceil = 1$ aléatoirement parmis son
voisinnage. Dans ce cas, il choisit $p_9$ parmis $\{p_9,\,p_8,\,p_7\}$. Il
envoie à $p_1$ cet échantillon auquel est ajoutée sa propre identité. En
réponse, le pair $p_1$ choisit
$\left\lceil{|\mathcal{P}_1|\div 2}\right\rceil = 1$ pair de sa vue
partielle. L'échantillon composé du seul voisin $p_2$ est envoyé. Immédiatement
après, $p_1$ peut supprimer l'échantillon envoyé et intégrer celui réçu
résultant en une vue partielle composée de $\{p_6,\, p_9\}$. De la même façon,
après réception de l'échantillon de $p_1$, $p_6$ supprime et intègre les
échantillons adéquats, résultant en une vue partielle composée de
$\{p_2,\,p_7,\,p_8\}$.

La procédure d'échange tend à réduire l'écart de taille des vues partielles. De
plus, elle disperse les références aux pairs afin de supprimer les groupes trop
denses dûes à la procédure d'entrée dans le réseau.

En ce qui concerne le temps de converge de l'algorithme de mélange, il existe
une relation proche entre \SPRAY et le protocole d'aggrégation proactive
présenté dans~\cite{jelasity2004epidemic, montresor2004robust}. Celui-ci déclare
que, sous l'hypothèse d'un échantillonnage suffisamment aléatoire, la valeur
moyenne $\mu$ et la variance $\sigma^2$ a un cycle $i$ sont :
\begin{center}
  $\mu_i = {1\over{|\mathcal{N}|}} \sum\limits_{x \in \mathcal{N}} a_{i,\,x}$
  \hfill
  $\sigma^2_i = {1\over{|\mathcal{N}|-1}}\sum\limits_{x \in \mathcal{N}}
  (a_{i,\,x} - \mu_i)^2$
\end{center}
avec $a_{i,\,x}$ la valeur stockée par le pair $p_x$ au cycle $i$. La variance
estimée doit converger en 0 au cours des cycles. En d'autres termes, les valeurs
se rapprochent les unes des autres au cours des cycles. Dans le cas de \SPRAY,
cette valeur $a_{i,\,x}$ est la taille de la vue partiel du pair $p_x$ au cycle
$i$. En effet, chaque échange du pair $p_1$ et du pair $p_2$ est une aggrégation
dont le résultat est :
$|\mathcal{P}_1|\approx|\mathcal{P}_2|\approx{(|\mathcal{P}_1| +
  |\mathcal{P}_2|) \div 2}$.
De plus, à chaque cycle, chaque pair est impliqué dans un protocole d'échange au
moins une fois (celui qu'ils initient), and, dans le meilleur des cas
$1+Poisson(1)$ (celui qu'ils initient et, en moyenne, celui qu'ils réçoivent
d'un autre pair). Cette relation étant établie, nous en déduisons que la taille
des vues partielles des pairs de \SPRAY converge en temps exponentiel vers la
moyenne globale. De plus, chaque cycle réduit la variance du système global à un
taux compris entre ${1\div 2}$ et $1\div ({2\sqrt{\text{e}}})$.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../paper"
%%% End:
